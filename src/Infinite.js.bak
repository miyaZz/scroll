import React, {Component, PropTypes} from 'react';
import ReactDOM from 'react-dom';
const {findDOMNode} = ReactDOM;

class Infinite extends Component {
  static propTypes = {
    itemRenderer: PropTypes.func.isRequired, // æ¸²æŸ“listçš„æ–¹æ³•
    tombstoneRender: PropTypes.func,
    determinateSize: PropTypes.number, // è¾¹ç•Œ
    pageSize: PropTypes.number,
    preCount: PropTypes.number, // é¦–æ¬¡åŠ è½½æ•°é‡
    dataSource: PropTypes.oneOfType([
      PropTypes.array,
      PropTypes.func
    ])
  };

  static defaultProps = {
    determinateSize: 1000,
    pageSize: 20,
    preCount: 30,
    tombstoneRender: o => {
      return(
        <div className={o.id%2 ? 'item' : 'item-trip'} key={o.id} id={o.id}>
          æˆ‘å°±æ˜¯ä¸ªå åœ°ç›˜çš„
        </div>
      )
    }
  }

  constructor(props) {
    super(props);
    this.threshold = 300;
    this.async = typeof props.dataSource === 'function'
    this.state = {
      dataCache: this.async ? [] : props.dataSource, // å…¨éƒ¨æ•°æ®ç¼“å­˜
      length: this.async ? props.preCount : props.dataSource.length, // å·²ç¼“å­˜çš„æ•°æ®é•¿åº¦
      size: props.preCount, //æ¸²æŸ“domèŠ‚ç‚¹æ•°
      startIndex: 0, // å¼€å§‹ä½ç½®çš„Index,
      display: [] //éœ€å®é™…æ¸²æŸ“çš„æ•°æ®
    };
    this.cache = {}; // å­˜å‚¨èŠ‚ç‚¹ä¿¡æ¯ => {id: offsetheight, ...}
  }

  componentWillMount() {
    const {preCount, dataSource} = this.props;
    const {dataCache} = this.state;
    if(this.async) {
      let data = dataSource(null, preCount);
      this.setState({
        dataCache: data
      });
    }
  }

  componentDidMount() {
    const {dataCache} = this.state;
    window.addEventListener('resize', this.updateFrame);
    this.updateScrollParentDOM();
    const {start, end} = this.getStartAndEnd();
    const {index, count} = this.getTopItemAndSize(start, end);
    const {size} = this.state;
    this.setState({
      display: dataCache.slice(index, index + size)
    })
  }

  componentWillUpdate(nextProps, nextState) {
    const {dataSource, pageSize} = this.props;
    const {dataCache, length} = this.state;
    if(this.async) {
      if(nextState.length !== length) {
        let _self = this;
        let array = [];
        for(let i = length; i < length + pageSize; i++) {
          array.push({id: i, tombstone: true});
        }
        this.setState({
          dataCache: dataCache.concat(array),
        })
        setTimeout(() =>{
          let list = [];
          let add = [];
          add = add.concat(dataSource(length, pageSize));
          console.log(add, 'data')
          let tombstoneStartIndex = _.findIndex(dataCache, {tombstone: true});
          let tombstoneEndIndex = _.findLastIndex(dataCache, {tombstone: true});
          let _head = dataCache.slice(0, tombstoneStartIndex);
          let _end = dataCache.slice(tombstoneEndIndex + 1);
          if(!tombstoneStartIndex) {
            list = dataCache.concat(add);
          }else if(tombstoneEndIndex && tombstoneStartIndex && add.length < tombstoneEndIndex - tombstoneStartIndex + 1) {
            list = [
              ..._head,
              ...add,
              ..._end
            ];
          }else if(tombstoneEndIndex && tombstoneStartIndex &&  add.length >= tombstoneEndIndex - tombstoneStartIndex + 1){
            list = [
              ..._head,
              ...add
            ];
          }
          this.setState({
            dataCache: list
          });
        }, 3000);
      }
    }
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.updateFrame);
    this.scrollParent.removeEventListener('scroll', this.updateFrame);
    this.scrollParent.removeEventListener('mousewheel', () => {});
  }

  getScrollParentDOM = () => {
    let el = findDOMNode(this);
    while (el) {
      // è·å–å½“å‰å…ƒç´ çš„CSSå±æ€§
      switch (window.getComputedStyle(el).overflowY) {
        case 'auto': case 'scroll': case 'overlay': return el;
      }
      el = el.parentElement;
    }
    return window;
  }

  updateScrollParentDOM = () => {
    const prev = this.scrollParentDom;
    this.scrollParentDom = this.getScrollParentDOM();
    if (prev === this.scrollParentDom) return;
    if (prev) {
      prev.removeEventListener('scroll', this.updateFrame);
      prev.removeEventListener('mousewheel', () => {});
    }
    this.scrollParentDom.addEventListener('scroll', this.updateFrame);
    this.scrollParentDom.addEventListener('mousewheel', () => {});
  }

  // æ˜¯å¦ä¸å‰ä¸€ä¸ªçŠ¶æ€ç›¸ç­‰
  isEqualPrev = (prevState, nextState) => {
    for (let key in nextState) if (prevState[key] !== nextState[key]) return false;
    return true;
  };

  // setStateçš„å°è£…,åˆ¤æ–­æ˜¯å¦æ›´æ–°state
  shouldUpdateState = (nextState) => {
    if(this.isEqualPrev(this.state, nextState)) return;
    
    this.setState(nextState);
  }

  // è·å–æ»šåŠ¨æ¡
  getScrollTop = () => {
    const {scrollParentDom} = this;
    const scrollTop = scrollParentDom === window ?
      document.body.scrollTop || document.documentElement.scrollTop :
      scrollParentDom.scrollTop;
    return scrollTop;
  }

  // è·å–æ»šåŠ¨æ¡é«˜åº¦
  getScrollHeight = () => {
    const {scrollParentDom, cache} = this;
    const {body, documentElement} = document;
    let scrollHeight = scrollParentDom === window ?
      Math.max(body.scrollHeight, documentElement.scrollHeight) :
      scrollParentDom.scrollHeight;
    return scrollHeight
  }

  // è·å–æ»šåŠ¨è§†å£é«˜åº¦
  getViewportSize = () => {
    const {scrollParentDom} = this;
    let viewportSize = scrollParentDom === window ?
      window.innerHeight :
      scrollParentDom.clientHeight;
    return viewportSize;
  }

  updateFrame = cb => {
    const {dataSource, pageSize} = this.props;;
    const {length, dataCache} = this.state;
    this.updateScrollParentDOM();
    const {start, end} = this.getStartAndEnd();
    const {index, count} = this.getTopItemAndSize(start, end);    
    this.cacheSizes();
    // å¯ç¼“å­˜æ•°æ®æ•°æ®æ¯”å®é™…ç®—å‡ºçš„æœ€åä¸€ä¸ªå…ƒç´ çš„index
    if(this.async) {
      if(dataCache.length <= count + index) {
        this.asyncLoad(end);
      }
      let display = dataCache.slice(index, index + count);
      
      this.shouldUpdateState({startIndex: index, size: count, display});
    }else{
      const scrollHeight = this.getScrollHeight();
      if(count + index < dataSource.length) {
        let display = dataCache.slice(index, index + count);
        this.shouldUpdateState({startIndex: index, size: count, display});
      }
    }
  }

  asyncLoad = end => {
    const {length} = this.state;
    const {threshold} = this;
    const {determinateSize, pageSize} = this.props;
    const scrollHeight = this.getScrollHeight();
    let next = length;
    if(determinateSize) {
      if(length < determinateSize && scrollHeight < end) {
        next = length + pageSize > determinateSize ? determinateSize : length + pageSize;
      }else if(length > determinateSize) {
        next = determinateSize;
      }
    }else{
      next = length + pageSize
    }
    this.shouldUpdateState({length: next});
  }

  // è·å–ä¸Šä¸‹ä½ç½®
  getStartAndEnd() {
    const {threshold} = this;
    const scroll = this.getScrollTop();
    const start = Math.max(0, scroll - threshold);
    let end = scroll + this.getViewportSize() + threshold;
    return {start, end};
  }

  //è·å–è§†çª—å†…ç¬¬ä¸€æ¡å…ƒç´ çš„index,åŠåˆ°åº•éƒ¨é”šç‚¹çš„å…ƒç´ æ•°é‡
  getTopItemAndSize(start, end) {
    const {dataSource} = this.props;
    const {length} = this.state;
    const {pageSize} = this.props;
    const maxIndex = length - 1;
    let index = 0;
    let count = 0;
    let topHeight = 0;

    while (index < maxIndex) {
      const itemSize = this.getItemSize(index);
      if (!itemSize || topHeight + itemSize > start) break;
      topHeight += itemSize;
      ++index;
    }

    let maxSize = length - index;
    while (count < maxSize && topHeight < end) {
      const itemSize = this.getItemSize(index + count);
      if (!itemSize) {
        count = Math.min(count + pageSize, maxSize);
        break;
      }
      topHeight += itemSize;
      ++count;
    }
    return {index, count}
  }

  cacheSizes = () => {
    const {cache} = this;
    const itemEls = findDOMNode(this.doms).children;
    for (let i = 0; i < itemEls.length; ++i) {
      cache[itemEls[i].id] = itemEls[i].offsetHeight;
    }
  }

  getItemSize = index => {
    // stateè®¾ç½®å›ºå®šé«˜åº¦
    const {cache} = this;
    const {dataCache} = this.state;

    const {itemSize} = this.state;

    if(itemSize) return itemSize;

    if (dataCache[index]) return cache[dataCache[index].id];
  }

  getOffSet = () => {
    const {startIndex} = this.state;
    let top = 0;
    for(let i = 0; i < startIndex; i++) {
      if(this.cache[i]) {
        top += this.cache[i];
      }
    }
    return top;
  }

  tombstoneRender = o => {
    return(
      <div className={o.id%2 ? 'item' : 'item-trip'} key={o.id} id={o.id}>
        <div>ç‹‚æ‹½é…·ç‚«è„‘ç™½é‡‘ï¼Œæˆ‘å°±æ˜¯èŒä¸šå åœ°ç›˜äº†</div>
        <div>æ”¶è´¹æ ‡å‡†ï¼šå ä¸€ä¸ªä½100å—ï½</div>
        <div>ä½ å’‹æ»´ï¼Œä¸æœï¼Œä¸æœæˆ‘å°±èµ°ğŸ˜³</div>
      </div>
    )
  }

  itemsRenderer = (items, ref) => <div ref={ref}>{items}</div>;

  renderItems() {
    const {startIndex, size, display, dataCache} = this.state;
    const {itemRenderer, tombstoneRender} = this.props;
    const items = [];
    for (let i = 0; i < display.length; ++i) {
      if(display[i].tombstone) {
        items.push(tombstoneRender(display[i]));
      }else{
        items.push(itemRenderer(display[i]));
      }
    };
    return this.itemsRenderer(items, c => this.doms = c);
  }

  render() {
    const {preCount, pageSize, determinateSize, dataSource, itemRenderer, tombstoneRender, ...props} = this.props;
    const items = this.renderItems();
    let y = this.getOffSet();
    const transform = `translate(0px, ${y}px)`;
    const listStyle = {
      msTransform: transform,
      WebkitTransform: transform,
      transform
    };
    return (
      <div {...props}>
        <div style={listStyle}>
          {items}
        </div>
      </div>
    );
  }
}

export default Infinite;
